{"version":3,"file":"vendors-node_modules_tanstack_react-router_dist_esm_index_js.js","mappings":";;;;;;;;;;;;;;AAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,yBAAyB,sDAAG;AAC5B;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA,2BAA2B,aAAoB;AAC/C,EAAE,SAAS;AACX;AACA;AACA;AACA;AACA;AAGE;AACF;;;;;;;;;;;;;;;;;;;;;;;AC5BwC;AACT;AACI;AACQ;AACS;AACjB;AACiD;AACpF;AACA;AACA,CAAC;AACD;AACA,iBAAiB,wDAAS;AAC1B;AACA,EAAE,gDAAK;AACP;AACA;AACA;AACA;AACA;AACA,UAAU,wEAAiB;AAC3B,4FAA4F,0EAAuB;AACnH,QAAQ;AACR,QAAQ,wDAAO;AACf;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,0FAA0F,6DAAqB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAG,eAAe,UAAU;AAC5D;AACA,2BAA2B,sDAAG,CAAC,2CAAc,IAAI,2CAA2C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AAIE;AACF;;;;;;;;;;;;;;;;ACpDoD;AACpD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sEAAsE,6DAAqB;AAC3F;AACA;AACA,KAAK;AACL;AACA;AACA;AAGE;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBgH;AAC3D;AACF;AACF;AACJ;AACV;AACgC;AAC2D;AACjE;AACF;AAC+D;AACzE;AACN;AACyC;AAC3C;AACU;AACA;AAC8H;AACvI;AACY;AACd;AAC6I;AAC1B;AAC/E;AACmC;AACM;AAC/D;AACF;AACK;AACd;AACA;AACW;AACC;AACZ;AACU;AACN;AACiJ;AACpG;AA6G1F;AACF;;;;;;;;;;;;;;;;;;;;ACnJkD;AACnB;AACK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yCAAyC,sDAAG,CAAC,uDAAQ,IAAI,UAAU,oBAAoB,sDAAG,CAAC,uDAAQ,IAAI,oBAAoB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uDAA0B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAG,eAAe,0BAA0B,sDAAG,CAAC,6CAAM,IAAI,aAAa,gDAAmB,eAAe;AACtI;AACA,WAAW,gDAAmB;AAC9B;AACA;AACA;AACA;AAKE;AACF;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACwC;AACT;AACO;AACe;AACV;AACwD;AACpC;AAC/D;AACA;AACA,iBAAiB,wDAAS;AAC1B,gDAAgD,2CAAc;AAC9D,mBAAmB,0DAAe;AAClC;AACA;AACA,2BAA2B,qBAAqB;AAChD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,0CAAa;AAC5B;AACA,iBAAiB,GAAG;AACpB;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH,eAAe,0CAAa;AAC5B;AACA;AACA;AACA,kBAAkB,0CAAa;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,kEAAc;AACjC;AACA,+BAA+B,6DAAmB;AAClD;AACA;AACA;AACA,4BAA4B,6DAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,uDAAa;AAC7F;AACA,kGAAkG,oDAAS;AAC3G;AACA;AACA,GAAG;AACH,oBAAoB,8CAAiB;AACrC;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,oCAAoC,8CAAiB;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,EAAE,kEAAuB;AACzB;AACA;AACA,MAAM,qBAAqB;AAC3B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,qBAAqB,QAAQ;AAC7B,uBAAuB,UAAU;AACjC,oBAAoB,OAAO;AAC3B,wBAAwB,WAAW;AACnC,sBAAsB,SAAS;AAC/B,sBAAsB,SAAS;AAC/B,2BAA2B,cAAc;AACzC,2BAA2B,cAAc;AACzC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,MAAM,oDAAS;AACf;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,2DAAgB,gBAAgB,QAAQ;AACjF,8CAA8C,EAAE,2DAAgB,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sBAAsB;AACpE,8BAA8B,8BAA8B;AAC5D;AACA;AACA;AACA,KAAK;AACL,qBAAqB,iDAAiD;AACtE,4BAA4B;AAC5B;AACA;AACA;AACA,SAAS,6CAAgB;AACzB,2BAA2B,sDAAG,SAAS,+BAA+B;AACtE,GAAG;AACH;AACA,aAAa,6CAAgB;AAC7B;AACA,YAAY,oBAAoB;AAChC,YAAY,oCAAoC;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,gDAAmB;AAC9B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AAKE;AACF;;;;;;;;;;;;;;;;;;;;AClP+B;AACY;AACG;AAC9C,wDAAwD,kDAAqB,GAAG,4CAAe;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA,oBAAoB,2DAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,iBAAiB,wDAAS;AAC1B;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAS;AAC1B;AACA;AACA;AACA,sDAAsD,WAAW;AACjE,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,WAAW,aAAa,yCAAyC;AAC1E;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AAKE;AACF;;;;;;;;;;;;;;;;;;ACtK+B;AACY;AAC3C;AACA,UAAU,8BAA8B,8DAA8D,kEAAkE;AACxK;AACA;AACA,IAAI,IAAI;AACR,UAAU,UAAU,EAAE,wDAAS;AAC/B,kCAAkC,2CAAc;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH,EAAE,4CAAe;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iBAAiB,gCAAgC;AACjD,gCAAgC,sBAAsB;AACtD;AACA;AAIE;AACF;;;;;;;;;;;;;;;;ACjDqD;AACrD;AACA,SAAS,kEAAc;AACvB;AACA,GAAG;AACH;AAGE;AACF;;;;;;;;;;;;;;;;ACTyC;AACzC;AACA,SAAS,sDAAQ;AACjB;AACA;AACA,GAAG;AACH;AAGE;AACF","sources":["webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/ScriptOnce.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/awaited.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/defer.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/index.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/lazyRouteComponent.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/link.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/scroll-restoration.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/useBlocker.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/useLocation.js","webpack://simplybook_app/./node_modules/@tanstack/react-router/dist/esm/useRouteContext.js"],"sourcesContent":["import { jsx } from \"react/jsx-runtime\";\nfunction ScriptOnce({\n  className,\n  children,\n  log,\n  ...rest\n}) {\n  if (typeof document !== \"undefined\") {\n    return null;\n  }\n  return /* @__PURE__ */ jsx(\n    \"script\",\n    {\n      ...rest,\n      className: `tsr-once ${className || \"\"}`,\n      dangerouslySetInnerHTML: {\n        __html: [\n          children,\n          (log ?? true) && process.env.NODE_ENV === \"development\" ? `console.info(\\`Injected From Server:\n${children}\\`)` : \"\"\n        ].filter(Boolean).join(\"\\n\")\n      }\n    }\n  );\n}\nexport {\n  ScriptOnce\n};\n//# sourceMappingURL=ScriptOnce.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport warning from \"tiny-warning\";\nimport { useRouter } from \"./useRouter.js\";\nimport { defaultSerializeError } from \"./router.js\";\nimport { defer } from \"./defer.js\";\nimport { isServerSideError, defaultDeserializeError } from \"./isServerSideError.js\";\nfunction useAwaited({\n  promise: _promise\n}) {\n  var _a, _b;\n  const router = useRouter();\n  const promise = _promise;\n  defer(promise);\n  if (promise.status === \"pending\") {\n    throw promise;\n  }\n  if (promise.status === \"error\") {\n    if (typeof document !== \"undefined\") {\n      if (isServerSideError(promise.error)) {\n        throw (((_a = router.options.errorSerializer) == null ? void 0 : _a.deserialize) ?? defaultDeserializeError)(promise.error.data);\n      } else {\n        warning(\n          false,\n          \"Encountered a server-side error that doesn't fit the expected shape\"\n        );\n        throw promise.error;\n      }\n    } else {\n      throw {\n        data: (((_b = router.options.errorSerializer) == null ? void 0 : _b.serialize) ?? defaultSerializeError)(promise.error),\n        __isServerError: true\n      };\n    }\n  }\n  return [promise.data, promise];\n}\nfunction Await(props) {\n  const inner = /* @__PURE__ */ jsx(AwaitInner, { ...props });\n  if (props.fallback) {\n    return /* @__PURE__ */ jsx(React.Suspense, { fallback: props.fallback, children: inner });\n  }\n  return inner;\n}\nfunction AwaitInner(props) {\n  const [data] = useAwaited(props);\n  return props.children(data);\n}\nexport {\n  Await,\n  useAwaited\n};\n//# sourceMappingURL=awaited.js.map\n","import { defaultSerializeError } from \"./router.js\";\nfunction defer(_promise, options) {\n  const promise = _promise;\n  if (!promise.status) {\n    Object.assign(promise, {\n      status: \"pending\"\n    });\n    promise.then((data) => {\n      promise.status = \"success\";\n      promise.data = data;\n    }).catch((error) => {\n      promise.status = \"error\";\n      promise.error = {\n        data: ((options == null ? void 0 : options.serializeError) ?? defaultSerializeError)(error),\n        __isServerError: true\n      };\n    });\n  }\n  return promise;\n}\nexport {\n  defer\n};\n//# sourceMappingURL=defer.js.map\n","import { createBrowserHistory, createHashHistory, createHistory, createMemoryHistory } from \"@tanstack/history\";\nimport { default as default2 } from \"tiny-invariant\";\nimport { default as default3 } from \"tiny-warning\";\nimport { Await, useAwaited } from \"./awaited.js\";\nimport { ScriptOnce } from \"./ScriptOnce.js\";\nimport { defer } from \"./defer.js\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { FileRoute, FileRouteLoader, LazyRoute, createFileRoute, createLazyFileRoute, createLazyRoute } from \"./fileRoute.js\";\nimport { lazyRouteComponent } from \"./lazyRouteComponent.js\";\nimport { Link, createLink, useLinkProps } from \"./link.js\";\nimport { MatchRoute, Matches, isMatch, useChildMatches, useMatchRoute, useMatches, useParentMatches } from \"./Matches.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { Match, Outlet } from \"./Match.js\";\nimport { defaultDeserializeError, isServerSideError } from \"./isServerSideError.js\";\nimport { useMatch } from \"./useMatch.js\";\nimport { useLoaderDeps } from \"./useLoaderDeps.js\";\nimport { useLoaderData } from \"./useLoaderData.js\";\nimport { cleanPath, interpolatePath, joinPaths, matchByPath, matchPathname, parsePathname, removeBasepath, resolvePath, trimPath, trimPathLeft, trimPathRight } from \"./path.js\";\nimport { decode, encode } from \"./qss.js\";\nimport { isRedirect, redirect } from \"./redirects.js\";\nimport { rootRouteId } from \"./root.js\";\nimport { NotFoundRoute, RootRoute, Route, RouteApi, createRootRoute, createRootRouteWithContext, createRoute, createRouteMask, getRouteApi, rootRouteWithContext } from \"./route.js\";\nimport { PathParamError, Router, SearchParamError, componentTypes, createRouter, defaultSerializeError, getInitialRouterState, lazyFn } from \"./router.js\";\nimport { RouterContextProvider, RouterProvider } from \"./RouterProvider.js\";\nimport { ScrollRestoration, useElementScrollRestoration, useScrollRestoration } from \"./scroll-restoration.js\";\nimport { defaultParseSearch, defaultStringifySearch, parseSearchWith, stringifySearchWith } from \"./searchParams.js\";\nimport { defaultTransformer } from \"./transformer.js\";\nimport { Block, useBlocker } from \"./useBlocker.js\";\nimport { Navigate, useNavigate } from \"./useNavigate.js\";\nimport { useParams } from \"./useParams.js\";\nimport { useSearch } from \"./useSearch.js\";\nimport { getRouterContext } from \"./routerContext.js\";\nimport { useRouteContext } from \"./useRouteContext.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useLocation } from \"./useLocation.js\";\nimport { createControlledPromise, deepEqual, escapeJSON, functionalUpdate, isPlainArray, isPlainObject, pick, replaceEqualDeep, shallow, useLayoutEffect, useStableCallback } from \"./utils.js\";\nimport { CatchNotFound, DefaultGlobalNotFound, isNotFound, notFound } from \"./not-found.js\";\nexport {\n  Await,\n  Block,\n  CatchBoundary,\n  CatchNotFound,\n  DefaultGlobalNotFound,\n  ErrorComponent,\n  FileRoute,\n  FileRouteLoader,\n  LazyRoute,\n  Link,\n  Match,\n  MatchRoute,\n  Matches,\n  Navigate,\n  NotFoundRoute,\n  Outlet,\n  PathParamError,\n  RootRoute,\n  Route,\n  RouteApi,\n  Router,\n  RouterContextProvider,\n  RouterProvider,\n  ScriptOnce,\n  ScrollRestoration,\n  SearchParamError,\n  cleanPath,\n  componentTypes,\n  createBrowserHistory,\n  createControlledPromise,\n  createFileRoute,\n  createHashHistory,\n  createHistory,\n  createLazyFileRoute,\n  createLazyRoute,\n  createLink,\n  createMemoryHistory,\n  createRootRoute,\n  createRootRouteWithContext,\n  createRoute,\n  createRouteMask,\n  createRouter,\n  decode,\n  deepEqual,\n  defaultDeserializeError,\n  defaultParseSearch,\n  defaultSerializeError,\n  defaultStringifySearch,\n  defaultTransformer,\n  defer,\n  encode,\n  escapeJSON,\n  functionalUpdate,\n  getInitialRouterState,\n  getRouteApi,\n  getRouterContext,\n  interpolatePath,\n  default2 as invariant,\n  isMatch,\n  isNotFound,\n  isPlainArray,\n  isPlainObject,\n  isRedirect,\n  isServerSideError,\n  joinPaths,\n  lazyFn,\n  lazyRouteComponent,\n  matchByPath,\n  matchContext,\n  matchPathname,\n  notFound,\n  parsePathname,\n  parseSearchWith,\n  pick,\n  redirect,\n  removeBasepath,\n  replaceEqualDeep,\n  resolvePath,\n  rootRouteId,\n  rootRouteWithContext,\n  shallow,\n  stringifySearchWith,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n  useAwaited,\n  useBlocker,\n  useChildMatches,\n  useElementScrollRestoration,\n  useLayoutEffect,\n  useLinkProps,\n  useLoaderData,\n  useLoaderDeps,\n  useLocation,\n  useMatch,\n  useMatchRoute,\n  useMatches,\n  useNavigate,\n  useParams,\n  useParentMatches,\n  useRouteContext,\n  useRouter,\n  useRouterState,\n  useScrollRestoration,\n  useSearch,\n  useStableCallback,\n  default3 as warning\n};\n//# sourceMappingURL=index.js.map\n","import { jsx, Fragment } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { Outlet } from \"./Match.js\";\nfunction isModuleNotFoundError(error) {\n  return typeof (error == null ? void 0 : error.message) === \"string\" && /Failed to fetch dynamically imported module/.test(error.message);\n}\nfunction ClientOnly({\n  children,\n  fallback = null\n}) {\n  return useHydrated() ? /* @__PURE__ */ jsx(Fragment, { children }) : /* @__PURE__ */ jsx(Fragment, { children: fallback });\n}\nfunction subscribe() {\n  return () => {\n  };\n}\nfunction useHydrated() {\n  return React.useSyncExternalStore(\n    subscribe,\n    () => true,\n    () => false\n  );\n}\nfunction lazyRouteComponent(importer, exportName, ssr) {\n  let loadPromise;\n  let comp;\n  let error;\n  const load = () => {\n    if (typeof document === \"undefined\" && (ssr == null ? void 0 : ssr()) === false) {\n      comp = () => null;\n      return Promise.resolve();\n    }\n    if (!loadPromise) {\n      loadPromise = importer().then((res) => {\n        loadPromise = void 0;\n        comp = res[exportName ?? \"default\"];\n      }).catch((err) => {\n        error = err;\n      });\n    }\n    return loadPromise;\n  };\n  const lazyComp = function Lazy(props) {\n    if (error) {\n      if (isModuleNotFoundError(error)) {\n        if (error instanceof Error && typeof window !== \"undefined\" && typeof sessionStorage !== \"undefined\") {\n          const storageKey = `tanstack_router_reload:${error.message}`;\n          if (!sessionStorage.getItem(storageKey)) {\n            sessionStorage.setItem(storageKey, \"1\");\n            window.location.reload();\n            return {\n              default: () => null\n            };\n          }\n        }\n      }\n      throw error;\n    }\n    if (!comp) {\n      throw load();\n    }\n    if ((ssr == null ? void 0 : ssr()) === false) {\n      return /* @__PURE__ */ jsx(ClientOnly, { fallback: /* @__PURE__ */ jsx(Outlet, {}), children: React.createElement(comp, props) });\n    }\n    return React.createElement(comp, props);\n  };\n  lazyComp.preload = load;\n  return lazyComp;\n}\nexport {\n  ClientOnly,\n  lazyRouteComponent,\n  useHydrated\n};\n//# sourceMappingURL=lazyRouteComponent.js.map\n","\"use client\";\nimport { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useForwardedRef, deepEqual, useIntersectionObserver, functionalUpdate } from \"./utils.js\";\nimport { removeTrailingSlash, exactPathTest } from \"./path.js\";\nconst preloadWarning = \"Error preloading route! ☝️\";\nfunction useLinkProps(options, forwardedRef) {\n  const router = useRouter();\n  const [isTransitioning, setIsTransitioning] = React.useState(false);\n  const innerRef = useForwardedRef(forwardedRef);\n  const {\n    // custom props\n    activeProps = () => ({ className: \"active\" }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ignoreBlocker,\n    ...rest\n  } = options;\n  const type = React.useMemo(() => {\n    try {\n      new URL(`${to}`);\n      return \"external\";\n    } catch {\n    }\n    return \"internal\";\n  }, [to]);\n  const next = React.useMemo(\n    () => router.buildLocation(options),\n    [router, options]\n  );\n  const preload = React.useMemo(\n    () => userPreload ?? router.options.defaultPreload,\n    [router.options.defaultPreload, userPreload]\n  );\n  const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;\n  const isActive = useRouterState({\n    select: (s) => {\n      const currentPathSplit = removeTrailingSlash(\n        s.location.pathname,\n        router.basepath\n      ).split(\"/\");\n      const nextPathSplit = removeTrailingSlash(\n        next.pathname,\n        router.basepath\n      ).split(\"/\");\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i]\n      );\n      const pathTest = (activeOptions == null ? void 0 : activeOptions.exact) ? exactPathTest(s.location.pathname, next.pathname, router.basepath) : pathIsFuzzyEqual;\n      const hashTest = (activeOptions == null ? void 0 : activeOptions.includeHash) ? s.location.hash === next.hash : true;\n      const searchTest = (activeOptions == null ? void 0 : activeOptions.includeSearch) ?? true ? deepEqual(s.location.search, next.search, !(activeOptions == null ? void 0 : activeOptions.exact)) : true;\n      return pathTest && hashTest && searchTest;\n    }\n  });\n  const doPreload = React.useCallback(() => {\n    router.preloadRoute(options).catch((err) => {\n      console.warn(err);\n      console.warn(preloadWarning);\n    });\n  }, [options, router]);\n  const preloadViewportIoCallback = React.useCallback(\n    (entry) => {\n      if (entry == null ? void 0 : entry.isIntersecting) {\n        doPreload();\n      }\n    },\n    [doPreload]\n  );\n  useIntersectionObserver(\n    innerRef,\n    preloadViewportIoCallback,\n    { rootMargin: \"100px\" },\n    { disabled: !!disabled || preload !== \"viewport\" }\n  );\n  if (type === \"external\") {\n    return {\n      ...rest,\n      ref: innerRef,\n      type,\n      href: to,\n      ...children && { children },\n      ...target && { target },\n      ...disabled && { disabled },\n      ...style && { style },\n      ...className && { className },\n      ...onClick && { onClick },\n      ...onFocus && { onFocus },\n      ...onMouseEnter && { onMouseEnter },\n      ...onMouseLeave && { onMouseLeave },\n      ...onTouchStart && { onTouchStart }\n    };\n  }\n  const handleClick = (e) => {\n    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === \"_self\") && e.button === 0) {\n      e.preventDefault();\n      flushSync(() => {\n        setIsTransitioning(true);\n      });\n      const unsub = router.subscribe(\"onResolved\", () => {\n        unsub();\n        setIsTransitioning(false);\n      });\n      router.commitLocation({\n        ...next,\n        replace,\n        resetScroll,\n        startTransition,\n        viewTransition,\n        ignoreBlocker\n      });\n    }\n  };\n  const handleFocus = (_) => {\n    if (disabled) return;\n    if (preload) {\n      doPreload();\n    }\n  };\n  const handleTouchStart = handleFocus;\n  const handleEnter = (e) => {\n    if (disabled) return;\n    const eventTarget = e.target || {};\n    if (preload) {\n      if (eventTarget.preloadTimeout) {\n        return;\n      }\n      eventTarget.preloadTimeout = setTimeout(() => {\n        eventTarget.preloadTimeout = null;\n        doPreload();\n      }, preloadDelay);\n    }\n  };\n  const handleLeave = (e) => {\n    if (disabled) return;\n    const eventTarget = e.target || {};\n    if (eventTarget.preloadTimeout) {\n      clearTimeout(eventTarget.preloadTimeout);\n      eventTarget.preloadTimeout = null;\n    }\n  };\n  const composeHandlers = (handlers) => (e) => {\n    var _a;\n    (_a = e.persist) == null ? void 0 : _a.call(e);\n    handlers.filter(Boolean).forEach((handler) => {\n      if (e.defaultPrevented) return;\n      handler(e);\n    });\n  };\n  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};\n  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {});\n  const resolvedClassName = [\n    className,\n    resolvedActiveProps.className,\n    resolvedInactiveProps.className\n  ].filter(Boolean).join(\" \");\n  const resolvedStyle = {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style\n  };\n  return {\n    ...rest,\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    href: disabled ? void 0 : next.maskedLocation ? router.history.createHref(next.maskedLocation.href) : router.history.createHref(next.href),\n    ref: innerRef,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    disabled: !!disabled,\n    target,\n    ...Object.keys(resolvedStyle).length && { style: resolvedStyle },\n    ...resolvedClassName && { className: resolvedClassName },\n    ...disabled && {\n      role: \"link\",\n      \"aria-disabled\": true\n    },\n    ...isActive && { \"data-status\": \"active\", \"aria-current\": \"page\" },\n    ...isTransitioning && { \"data-transitioning\": \"transitioning\" }\n  };\n}\nfunction createLink(Comp) {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return /* @__PURE__ */ jsx(Link, { ...props, _asChild: Comp, ref });\n  });\n}\nconst Link = React.forwardRef(\n  (props, ref) => {\n    const { _asChild, ...rest } = props;\n    const { type, ref: innerRef, ...linkProps } = useLinkProps(rest, ref);\n    const children = typeof rest.children === \"function\" ? rest.children({\n      isActive: linkProps[\"data-status\"] === \"active\"\n    }) : rest.children;\n    if (typeof _asChild === \"undefined\") {\n      delete linkProps.disabled;\n    }\n    return React.createElement(\n      _asChild ? _asChild : \"a\",\n      {\n        ...linkProps,\n        ref: innerRef\n      },\n      children\n    );\n  }\n);\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\nexport {\n  Link,\n  createLink,\n  useLinkProps\n};\n//# sourceMappingURL=link.js.map\n","import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nimport { functionalUpdate } from \"./utils.js\";\nconst useLayoutEffect = typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst windowKey = \"window\";\nconst delimiter = \"___\";\nlet weakScrolledElements = /* @__PURE__ */ new WeakSet();\nconst sessionsStorage = typeof window !== \"undefined\" && window.sessionStorage;\nconst cache = sessionsStorage ? (() => {\n  const storageKey = \"tsr-scroll-restoration-v2\";\n  const state = JSON.parse(\n    window.sessionStorage.getItem(storageKey) || \"null\"\n  ) || { cached: {}, next: {} };\n  return {\n    state,\n    set: (updater) => {\n      cache.state = functionalUpdate(updater, cache.state);\n      window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));\n    }\n  };\n})() : void 0;\nconst defaultGetKey = (location) => {\n  return location.state.key || location.href;\n};\nfunction useScrollRestoration(options) {\n  const router = useRouter();\n  useLayoutEffect(() => {\n    const getKey = (options == null ? void 0 : options.getKey) || defaultGetKey;\n    const { history } = window;\n    history.scrollRestoration = \"manual\";\n    const onScroll = (event) => {\n      if (weakScrolledElements.has(event.target)) return;\n      weakScrolledElements.add(event.target);\n      let elementSelector = \"\";\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey;\n      } else {\n        const attrId = event.target.getAttribute(\n          \"data-scroll-restoration-id\"\n        );\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`;\n        } else {\n          elementSelector = getCssSelector(event.target);\n        }\n      }\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN\n            }\n          }\n        }));\n      }\n    };\n    if (typeof document !== \"undefined\") {\n      document.addEventListener(\"scroll\", onScroll, true);\n    }\n    const unsubOnBeforeLoad = router.subscribe(\"onBeforeLoad\", (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation);\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector];\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0;\n            entry.scrollY = window.scrollY || 0;\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector);\n            entry.scrollX = (element == null ? void 0 : element.scrollLeft) || 0;\n            entry.scrollY = (element == null ? void 0 : element.scrollTop) || 0;\n          }\n          cache.set((c) => {\n            const next = { ...c.next };\n            delete next[elementSelector];\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry\n              }\n            };\n          });\n        }\n      }\n    });\n    const unsubOnResolved = router.subscribe(\"onResolved\", (event) => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return;\n        }\n        router.resetNextScroll = true;\n        const restoreKey = getKey(event.toLocation);\n        let windowRestored = false;\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey];\n          const [key, elementSelector] = cacheKey.split(delimiter);\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true;\n              window.scrollTo(entry.scrollX, entry.scrollY);\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector);\n              if (element) {\n                element.scrollLeft = entry.scrollX;\n                element.scrollTop = entry.scrollY;\n              }\n            }\n          }\n        }\n        if (!windowRestored) {\n          window.scrollTo(0, 0);\n        }\n        cache.set((c) => ({ ...c, next: {} }));\n        weakScrolledElements = /* @__PURE__ */ new WeakSet();\n      }\n    });\n    return () => {\n      document.removeEventListener(\"scroll\", onScroll);\n      unsubOnBeforeLoad();\n      unsubOnResolved();\n    };\n  }, [options == null ? void 0 : options.getKey, router]);\n}\nfunction ScrollRestoration(props) {\n  useScrollRestoration(props);\n  return null;\n}\nfunction useElementScrollRestoration(options) {\n  var _a;\n  const router = useRouter();\n  const getKey = options.getKey || defaultGetKey;\n  let elementSelector = \"\";\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`;\n  } else {\n    const element = (_a = options.getElement) == null ? void 0 : _a.call(options);\n    if (!element) {\n      return;\n    }\n    elementSelector = getCssSelector(element);\n  }\n  const restoreKey = getKey(router.latestLocation);\n  const cacheKey = [restoreKey, elementSelector].join(delimiter);\n  return cache.state.cached[cacheKey];\n}\nfunction getCssSelector(el) {\n  const path = [];\n  let parent;\n  while (parent = el.parentNode) {\n    path.unshift(\n      `${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`\n    );\n    el = parent;\n  }\n  return `${path.join(\" > \")}`.toLowerCase();\n}\nexport {\n  ScrollRestoration,\n  useElementScrollRestoration,\n  useScrollRestoration\n};\n//# sourceMappingURL=scroll-restoration.js.map\n","import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useBlocker(blockerFnOrOpts, condition) {\n  const { blockerFn, blockerCondition } = blockerFnOrOpts ? typeof blockerFnOrOpts === \"function\" ? { blockerFn: blockerFnOrOpts, blockerCondition: condition ?? true } : {\n    blockerFn: blockerFnOrOpts.blockerFn,\n    blockerCondition: blockerFnOrOpts.condition ?? true\n  } : { blockerFn: void 0, blockerCondition: condition ?? true };\n  const { history } = useRouter();\n  const [resolver, setResolver] = React.useState({\n    status: \"idle\",\n    proceed: () => {\n    },\n    reset: () => {\n    }\n  });\n  React.useEffect(() => {\n    const blockerFnComposed = async () => {\n      if (blockerFn) {\n        return await blockerFn();\n      }\n      const promise = new Promise((resolve) => {\n        setResolver({\n          status: \"blocked\",\n          proceed: () => resolve(true),\n          reset: () => resolve(false)\n        });\n      });\n      const canNavigateAsync = await promise;\n      setResolver({\n        status: \"idle\",\n        proceed: () => {\n        },\n        reset: () => {\n        }\n      });\n      return canNavigateAsync;\n    };\n    return !blockerCondition ? void 0 : history.block(blockerFnComposed);\n  }, [blockerFn, blockerCondition, history]);\n  return resolver;\n}\nfunction Block({ blockerFn, condition, children }) {\n  const resolver = useBlocker({ blockerFn, condition });\n  return children ? typeof children === \"function\" ? children(resolver) : children : null;\n}\nexport {\n  Block,\n  useBlocker\n};\n//# sourceMappingURL=useBlocker.js.map\n","import { useRouterState } from \"./useRouterState.js\";\nfunction useLocation(opts) {\n  return useRouterState({\n    select: (state) => (opts == null ? void 0 : opts.select) ? opts.select(state.location) : state.location\n  });\n}\nexport {\n  useLocation\n};\n//# sourceMappingURL=useLocation.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useRouteContext(opts) {\n  return useMatch({\n    ...opts,\n    select: (match) => opts.select ? opts.select(match.context) : match.context\n  });\n}\nexport {\n  useRouteContext\n};\n//# sourceMappingURL=useRouteContext.js.map\n"],"names":[],"sourceRoot":""}